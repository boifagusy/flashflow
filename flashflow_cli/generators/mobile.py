"""
Mobile Generator - Generates Flet-based mobile apps
"""

import os
import json
from pathlib import Path
from typing import Dict, Any
from jinja2 import Template

from ..core import FlashFlowProject, FlashFlowIR

class MobileGenerator:
    """Generates mobile app code from FlashFlow IR"""
    
    def __init__(self, project: FlashFlowProject, ir: FlashFlowIR, env: str = 'development'):
        self.project = project
        self.ir = ir
        self.env = env
        self.mobile_path = project.dist_path / "mobile"
    
    def generate_ios(self):
        """Generate iOS app using Flet"""
        self._generate_mobile_app('ios')
    
    def generate_android(self):
        """Generate Android app using Flet"""
        self._generate_mobile_app('android')
    
    def _generate_mobile_app(self, platform: str):
        """Generate mobile app for specified platform"""
        
        # Create mobile directory structure
        self._create_directory_structure(platform)
        
        # Generate main app file
        self._generate_main_app(platform)
        
        # Generate views/pages
        self._generate_mobile_views(platform)
        
        # Generate models and services
        self._generate_mobile_services(platform)
        
        # Generate platform-specific configs
        self._generate_platform_config(platform)
    
    def _create_directory_structure(self, platform: str):
        """Create mobile app directory structure"""
        
        platform_path = self.mobile_path / platform
        
        dirs = [
            platform_path,
            platform_path / "src",
            platform_path / "src" / "views", 
            platform_path / "src" / "components",
            platform_path / "src" / "services",
            platform_path / "src" / "models",
            platform_path / "src" / "utils",
            platform_path / "assets",
            platform_path / "assets" / "images",
            platform_path / "assets" / "icons"
        ]
        
        for dir_path in dirs:
            dir_path.mkdir(parents=True, exist_ok=True)
    
    def _generate_main_app(self, platform: str):
        """Generate main Flet application"""
        
        template = Template("""#!/usr/bin/env python3
\"\"\"
{{ project_name }} Mobile App - {{ platform.title() }}
Generated by FlashFlow

This is a Flet-based mobile application that provides offline-first
functionality with automatic sync to the FlashFlow backend.
\"\"\"

import flet as ft
import asyncio
import json
from pathlib import Path

from src.services.api_service import APIService
from src.services.storage_service import StorageService
from src.utils.theme import get_app_theme
{% for page_path, page_data in pages.items() %}from src.views.{{ page_data.view_name }} import {{ page_data.view_class }}
{% endfor %}

class {{ app_class_name }}:
    def __init__(self):
        self.api_service = APIService()
        self.storage_service = StorageService()
        self.current_user = None
        
    async def main(self, page: ft.Page):
        # Configure page
        page.title = "{{ project_name }}"
        page.theme_mode = ft.ThemeMode.LIGHT
        page.theme = get_app_theme()
        page.padding = 0
        page.spacing = 0
        
        # Set window properties for desktop testing
        if page.platform in [ft.PagePlatform.WINDOWS, ft.PagePlatform.MACOS, ft.PagePlatform.LINUX]:
            page.window_width = 375  # iPhone width for testing
            page.window_height = 812  # iPhone height for testing
            page.window_resizable = False
        
        # Initialize app state
        await self._initialize_app(page)
        
        # Set up navigation
        self._setup_navigation(page)
        
        # Load initial view
        await self._load_initial_view(page)
    
    async def _initialize_app(self, page: ft.Page):
        \"\"\"Initialize app state and services\"\"\"
        
        # Initialize storage
        await self.storage_service.initialize()
        
        # Check for saved user session
        saved_user = await self.storage_service.get_user()
        if saved_user:
            self.current_user = saved_user
        
        # Set up API service
        if self.current_user:
            self.api_service.set_auth_token(self.current_user.get('token'))
    
    def _setup_navigation(self, page: ft.Page):
        \"\"\"Set up app navigation\"\"\"
        
        def route_change(route):
            page.views.clear()
            
            # Route to appropriate view
            {% for page_path, page_data in pages.items() %}if page.route == "{{ page_path }}":
                view = {{ page_data.view_class }}(page, self)
                page.views.append(view.build())
            {% endfor %}else:
                # Default/404 view
                page.views.append(self._build_not_found_view(page))
            
            page.update()
        
        def view_pop(view):
            page.views.pop()
            top_view = page.views[-1]
            page.go(top_view.route)
        
        page.on_route_change = route_change
        page.on_view_pop = view_pop
    
    async def _load_initial_view(self, page: ft.Page):
        \"\"\"Load the initial view based on auth state\"\"\"
        
        if self.current_user:
            page.go("/dashboard")
        else:
            page.go("/")
    
    def _build_not_found_view(self, page: ft.Page):
        \"\"\"Build 404 not found view\"\"\"
        
        return ft.View(
            "/404",
            [
                ft.AppBar(title=ft.Text("Page Not Found"), bgcolor=ft.colors.SURFACE_VARIANT),
                ft.Container(
                    content=ft.Column([
                        ft.Text("Page Not Found", size=24, weight=ft.FontWeight.BOLD),
                        ft.Text("The requested page could not be found."),
                        ft.ElevatedButton(
                            "Go Home",
                            on_click=lambda _: page.go("/")
                        )
                    ], 
                    alignment=ft.MainAxisAlignment.CENTER,
                    horizontal_alignment=ft.CrossAxisAlignment.CENTER),
                    padding=20,
                    expand=True
                )
            ]
        )

def main():
    app = {{ app_class_name }}()
    ft.app(target=app.main, port=8080)

if __name__ == "__main__":
    main()
""")
        
        # Process pages for template
        pages_data = {}
        for page_path, page_data in self.ir.pages.items():
            view_name = self._path_to_view_name(page_path, page_data)
            pages_data[page_path] = {
                'view_name': view_name.lower(),
                'view_class': view_name
            }
        
        app_content = template.render(
            project_name=self.project.config.name,
            platform=platform,
            app_class_name=f"{self.project.config.name.replace(' ', '').replace('-', '')}App",
            pages=pages_data
        )
        
        platform_path = self.mobile_path / platform
        with open(platform_path / "main.py", 'w') as f:
            f.write(app_content)
    
    def _generate_mobile_views(self, platform: str):
        """Generate mobile views for each page"""
        
        platform_path = self.mobile_path / platform
        
        for page_path, page_data in self.ir.pages.items():
            self._generate_single_view(platform_path, page_path, page_data)
    
    def _generate_single_view(self, platform_path: Path, page_path: str, page_data: Dict):
        """Generate a single mobile view"""
        
        view_name = self._path_to_view_name(page_path, page_data)
        
        template = Template("""import flet as ft
from typing import Optional

class {{ view_class }}:
    def __init__(self, page: ft.Page, app):
        self.page = page
        self.app = app
        self.title = "{{ page_title }}"
        
    def build(self) -> ft.View:
        \"\"\"Build the {{ view_class }} view\"\"\"
        
        # Build components based on .flow definition
        content_controls = []
        
        {% for component in components %}{{ component }}
        {% endfor %}
        
        # Default content if no components defined
        if not content_controls:
            content_controls = [
                ft.Text(
                    "{{ page_title }}",
                    size=24,
                    weight=ft.FontWeight.BOLD
                ),
                ft.Text(
                    "This view is generated from your .flow file.\\n"
                    "Add more components to see them here.",
                    text_align=ft.TextAlign.CENTER
                ),
                ft.ElevatedButton(
                    "Refresh Data",
                    on_click=self._refresh_data
                )
            ]
        
        return ft.View(
            "{{ page_path }}",
            controls=[
                {% if show_app_bar %}ft.AppBar(
                    title=ft.Text(self.title),
                    bgcolor=ft.colors.PRIMARY,
                    color=ft.colors.ON_PRIMARY
                ),
                {% endif %}ft.Container(
                    content=ft.Column(
                        controls=content_controls,
                        alignment=ft.MainAxisAlignment.START,
                        horizontal_alignment=ft.CrossAxisAlignment.CENTER,
                        spacing=20
                    ),
                    padding=20,
                    expand=True
                )
            ],
            scroll=ft.ScrollMode.AUTO
        )
    
    async def _refresh_data(self, e):
        \"\"\"Refresh data from API\"\"\"
        try:
            # TODO: Implement data refresh based on page requirements
            self.page.show_snack_bar(
                ft.SnackBar(content=ft.Text("Data refreshed successfully"))
            )
        except Exception as error:
            self.page.show_snack_bar(
                ft.SnackBar(content=ft.Text(f"Error refreshing data: {str(error)}"))
            )
        
        self.page.update()
    
    def _handle_form_submit(self, e, form_data: dict):
        \"\"\"Handle form submission\"\"\"
        try:
            # TODO: Implement form submission to API
            self.page.show_snack_bar(
                ft.SnackBar(content=ft.Text("Form submitted successfully"))
            )
        except Exception as error:
            self.page.show_snack_bar(
                ft.SnackBar(content=ft.Text(f"Error submitting form: {str(error)}"))
            )
        
        self.page.update()
""")
        
        # Process page components
        components = []
        body = page_data.get('body', [])
        
        for component_def in body:
            if isinstance(component_def, dict):
                component_code = self._generate_mobile_component(component_def)
                components.append(component_code)
        
        view_content = template.render(
            view_class=view_name,
            page_title=page_data.get('title', 'Page'),
            page_path=page_path,
            show_app_bar=page_path != '/',  # Don't show app bar on home page
            components=components
        )
        
        view_file = platform_path / "src" / "views" / f"{view_name.lower()}.py"
        with open(view_file, 'w') as f:
            f.write(view_content)
    
    def _generate_mobile_component(self, component_def: Dict) -> str:
        """Generate Flet component code"""
        
        component_type = component_def.get('component', 'text')
        
        if component_type == 'hero':
            return f'''content_controls.extend([
            ft.Container(
                content=ft.Column([
                    ft.Text(
                        "{component_def.get('title', 'Welcome')}",
                        size=32,
                        weight=ft.FontWeight.BOLD,
                        text_align=ft.TextAlign.CENTER
                    ),
                    ft.Text(
                        "{component_def.get('subtitle', 'Built with FlashFlow')}",
                        size=16,
                        text_align=ft.TextAlign.CENTER
                    ),
                    ft.ElevatedButton(
                        "{component_def.get('cta', {}).get('text', 'Get Started')}",
                        on_click=lambda _: self.page.go("{component_def.get('cta', {}).get('link', '/dashboard')}")
                    )
                ], 
                alignment=ft.MainAxisAlignment.CENTER,
                horizontal_alignment=ft.CrossAxisAlignment.CENTER),
                padding=40,
                bgcolor=ft.colors.PRIMARY_CONTAINER,
                border_radius=10
            )
        ])'''
        
        elif component_type == 'form':
            fields = component_def.get('fields', [])
            field_controls = []
            
            for field in fields:
                field_name = field.get('name', 'field')
                field_type = field.get('type', 'text')
                placeholder = field.get('placeholder', '')
                
                if field_type == 'text':
                    field_controls.append(f'''ft.TextField(
                        label="{placeholder}",
                        hint_text="{placeholder}"
                    )''')
                elif field_type == 'email':
                    field_controls.append(f'''ft.TextField(
                        label="{placeholder}",
                        hint_text="{placeholder}",
                        keyboard_type=ft.KeyboardType.EMAIL
                    )''')
                elif field_type == 'password':
                    field_controls.append(f'''ft.TextField(
                        label="{placeholder}",
                        hint_text="{placeholder}",
                        password=True
                    )''')
            
            fields_code = ',\n                    '.join(field_controls)
            button_text = component_def.get('button_text', 'Submit')
            
            return f'''content_controls.append(
            ft.Container(
                content=ft.Column([
                    {fields_code},
                    ft.ElevatedButton(
                        "{button_text}",
                        on_click=lambda e: self._handle_form_submit(e, {{}})
                    )
                ], spacing=10),
                padding=20,
                bgcolor=ft.colors.SURFACE_VARIANT,
                border_radius=10
            )
        )'''
        
        elif component_type == 'list':
            return '''content_controls.append(
            ft.Container(
                content=ft.Column([
                    ft.Text("Data List", size=20, weight=ft.FontWeight.BOLD),
                    ft.Text("List items will appear here when connected to data")
                ]),
                padding=20,
                bgcolor=ft.colors.SURFACE_VARIANT,
                border_radius=10
            )
        )'''
        
        else:
            return f'''content_controls.append(
            ft.Text("Component: {component_type}")
        )'''
    
    def _generate_mobile_services(self, platform: str):
        """Generate mobile services (API, Storage, etc.)"""
        
        platform_path = self.mobile_path / platform
        
        # API Service
        api_service = Template("""import aiohttp
import json
from typing import Optional, Dict, Any

class APIService:
    def __init__(self):
        self.base_url = "http://localhost:8000/api"
        self.session: Optional[aiohttp.ClientSession] = None
        self.auth_token: Optional[str] = None
    
    async def _get_session(self) -> aiohttp.ClientSession:
        if self.session is None or self.session.closed:
            headers = {'Content-Type': 'application/json'}
            if self.auth_token:
                headers['Authorization'] = f'Bearer {self.auth_token}'
            
            self.session = aiohttp.ClientSession(headers=headers)
        return self.session
    
    def set_auth_token(self, token: str):
        self.auth_token = token
        if self.session and not self.session.closed:
            self.session.headers['Authorization'] = f'Bearer {token}'
    
    async def get(self, endpoint: str) -> Dict[str, Any]:
        session = await self._get_session()
        async with session.get(f"{self.base_url}{endpoint}") as response:
            return await response.json()
    
    async def post(self, endpoint: str, data: Dict[str, Any]) -> Dict[str, Any]:
        session = await self._get_session()
        async with session.post(f"{self.base_url}{endpoint}", json=data) as response:
            return await response.json()
    
    async def put(self, endpoint: str, data: Dict[str, Any]) -> Dict[str, Any]:
        session = await self._get_session()
        async with session.put(f"{self.base_url}{endpoint}", json=data) as response:
            return await response.json()
    
    async def delete(self, endpoint: str) -> Dict[str, Any]:
        session = await self._get_session()
        async with session.delete(f"{self.base_url}{endpoint}") as response:
            return await response.json()
    
    # Auto-generated model methods
    {% for model_name in models %}
    async def get_{{ model_name.lower() }}s(self):
        return await self.get("/{{ model_name.lower() }}s")
    
    async def get_{{ model_name.lower() }}(self, id: str):
        return await self.get(f"/{{ model_name.lower() }}s/{id}")
    
    async def create_{{ model_name.lower() }}(self, data: Dict[str, Any]):
        return await self.post("/{{ model_name.lower() }}s", data)
    
    async def update_{{ model_name.lower() }}(self, id: str, data: Dict[str, Any]):
        return await self.put(f"/{{ model_name.lower() }}s/{id}", data)
    
    async def delete_{{ model_name.lower() }}(self, id: str):
        return await self.delete(f"/{{ model_name.lower() }}s/{id}")
    {% endfor %}
    
    async def close(self):
        if self.session and not self.session.closed:
            await self.session.close()
""").render(models=list(self.ir.models.keys()))
        
        with open(platform_path / "src" / "services" / "api_service.py", 'w') as f:
            f.write(api_service)
        
        # Storage Service (for offline-first capabilities)
        storage_service = """import json
import asyncio
from pathlib import Path
from typing import Optional, Dict, Any

class StorageService:
    def __init__(self):
        self.data_dir = Path.home() / ".flashflow" / "data"
        self.user_file = self.data_dir / "user.json"
        self.cache_dir = self.data_dir / "cache"
    
    async def initialize(self):
        \"\"\"Initialize storage directories\"\"\"
        self.data_dir.mkdir(parents=True, exist_ok=True)
        self.cache_dir.mkdir(parents=True, exist_ok=True)
    
    async def save_user(self, user_data: Dict[str, Any]):
        \"\"\"Save user data to local storage\"\"\"
        with open(self.user_file, 'w') as f:
            json.dump(user_data, f, indent=2)
    
    async def get_user(self) -> Optional[Dict[str, Any]]:
        \"\"\"Get user data from local storage\"\"\"
        if self.user_file.exists():
            with open(self.user_file, 'r') as f:
                return json.load(f)
        return None
    
    async def clear_user(self):
        \"\"\"Clear user data from local storage\"\"\"
        if self.user_file.exists():
            self.user_file.unlink()
    
    async def cache_data(self, key: str, data: Any):
        \"\"\"Cache data locally\"\"\"
        cache_file = self.cache_dir / f"{key}.json"
        with open(cache_file, 'w') as f:
            json.dump(data, f, indent=2)
    
    async def get_cached_data(self, key: str) -> Optional[Any]:
        \"\"\"Get cached data\"\"\"
        cache_file = self.cache_dir / f"{key}.json"
        if cache_file.exists():
            with open(cache_file, 'r') as f:
                return json.load(f)
        return None
    
    async def clear_cache(self):
        \"\"\"Clear all cached data\"\"\"
        import shutil
        if self.cache_dir.exists():
            shutil.rmtree(self.cache_dir)
            self.cache_dir.mkdir()
"""
        
        with open(platform_path / "src" / "services" / "storage_service.py", 'w') as f:
            f.write(storage_service)
    
    def _generate_platform_config(self, platform: str):
        """Generate platform-specific configuration"""
        
        platform_path = self.mobile_path / platform
        
        # Theme configuration
        theme_colors = self.ir.theme.get('colors', {})
        
        theme_config = f"""import flet as ft

def get_app_theme() -> ft.Theme:
    \"\"\"Get FlashFlow app theme\"\"\"
    
    return ft.Theme(
        color_scheme_seed="{theme_colors.get('primary', '#3B82F6')}",
        visual_density=ft.ThemeVisualDensity.COMFORTABLE
    )

# Color constants
class AppColors:
    PRIMARY = "{theme_colors.get('primary', '#3B82F6')}"
    SECONDARY = "{theme_colors.get('secondary', '#64748B')}"
    SUCCESS = "{theme_colors.get('success', '#10B981')}"
    WARNING = "{theme_colors.get('warning', '#F59E0B')}"
    DANGER = "{theme_colors.get('danger', '#EF4444')}"
    LIGHT = "{theme_colors.get('light', '#F8FAFC')}"
    DARK = "{theme_colors.get('dark', '#0F172A')}"

# Common styles
class AppStyles:
    BUTTON_STYLE = ft.ButtonStyle(
        shape=ft.RoundedRectangleBorder(radius=8)
    )
    
    CARD_STYLE = {{
        "bgcolor": ft.colors.SURFACE_VARIANT,
        "border_radius": 12,
        "padding": 20
    }}
"""
        
        with open(platform_path / "src" / "utils" / "theme.py", 'w') as f:
            f.write(theme_config)
        
        # Requirements file
        requirements = """flet>=0.9.0
aiohttp>=3.8.0
asyncio-mqtt>=0.11.0
"""
        
        with open(platform_path / "requirements.txt", 'w') as f:
            f.write(requirements)
        
        # Platform-specific build script
        if platform == 'android':
            build_script = f"""#!/bin/bash
# Android Build Script for {self.project.config.name}

echo "Building Android APK..."

# Install dependencies
pip install -r requirements.txt

# Build APK
flet pack main.py --name "{self.project.config.name}" --platform android

echo "Android build completed!"
"""
        else:  # iOS
            build_script = f"""#!/bin/bash
# iOS Build Script for {self.project.config.name}

echo "Building iOS IPA..."

# Install dependencies  
pip install -r requirements.txt

# Build IPA (requires macOS and Xcode)
flet pack main.py --name "{self.project.config.name}" --platform ios

echo "iOS build completed!"
"""
        
        build_file = platform_path / "build.sh"
        with open(build_file, 'w') as f:
            f.write(build_script)
        
        # Make build script executable
        build_file.chmod(0o755)
    
    def _path_to_view_name(self, path: str, page_data: Dict) -> str:
        """Convert page path to mobile view class name"""
        
        # Use title if available
        if 'title' in page_data:
            title = page_data['title']
            # Remove common suffixes
            title = title.replace(' - ' + self.project.config.name, '')
            # Convert to PascalCase
            words = title.replace('-', ' ').replace('_', ' ').split()
            class_name = ''.join(word.capitalize() for word in words if word)
            if not class_name.endswith('View'):
                class_name += 'View'
            return class_name
        
        # Convert path to view name
        if path == '/':
            return 'HomeView'
        
        # Remove leading slash and convert to PascalCase
        path_parts = path.strip('/').split('/')
        class_name = ''.join(part.capitalize() for part in path_parts)
        
        if not class_name.endswith('View'):
            class_name += 'View'
        
        return class_name